import logging
import argparse
import torch.nn as nn
from collections import OrderedDict

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    filemode="a",
    filename="logs/discriminator.log",
)


class Discriminator(nn.Module):
    """
    Implements a Discriminator class for image-to-image translation tasks, following a typical convolutional neural network architecture used in Generative Adversarial Networks (GANs). This class is designed to distinguish between real images and fake images generated by the Generator.

    ## Parameters

    This class does not take parameters in its constructor.

    ## Attributes

    | Attribute | Type            | Description                                              |
    |-----------|-----------------|----------------------------------------------------------|
    | model     | `nn.Sequential` | A sequential container of layers defining the discriminator model. |

    The model consists of a series of convolutional layers with increasing depth, LeakyReLU activations for non-linearity, and BatchNorm layers for stabilization. The input to the discriminator is expected to be a concatenated tensor of the real image and the condition (or the generated image for fake detection), thus having a channel depth of `3 * 2` for the initial layer.

    ## Methods

    - `forward(x)`: Defines the forward pass of the discriminator with input `x`.

    ## Example Usage

    ```python
    # Assuming you have PyTorch and necessary libraries installed.
    # Create an instance of the Discriminator.
    netD = Discriminator()

    # Assuming `x` is a batch of concatenated real and fake (or condition) images with shape [batch_size, 6, height, width].
    # Determine the realness or fakeness of the images.
    output = netD(x)
    ```

    This model is crucial in a GAN setup for training the Generator to produce increasingly realistic images, as it learns to minimize the ability of the Discriminator to distinguish generated images from real ones.

    """

    def __init__(self):
        """
        Initializes the Discriminator model with a predefined sequence of layers configured to take concatenated real and generated images as input and output a single value indicating the perceived authenticity of the input images.
        """
        super(Discriminator, self).__init__()
        self.layers_config = [
            (3 * 2, 64, 4, 2, 1, 0.2, False),
            (64, 128, 4, 2, 1, 0.2, True),
            (128, 256, 4, 2, 1, 0.2, True),
            (256, 512, 4, 1, 1, 0.2, True),
            (512, 1, 4, 1, 1),
        ]

        self.model = self.connected_layer(layers_config=self.layers_config)

    def connected_layer(self, layers_config=None):
        layers = OrderedDict()
        if layers_config is not None:
            for index, (
                in_channels,
                out_channels,
                kernel_size,
                stride,
                padding,
                slope,
                batch_norm,
            ) in enumerate(self.layers_config[:-1]):
                layers[f"conv2d_{index+1}"] = nn.Conv2d(
                    in_channels, out_channels, kernel_size, stride, padding, bias=False
                )
                layers[f"leakyReLU_{index+1}"] = nn.LeakyReLU(slope, inplace=True)
                if batch_norm:
                    layers[f"batchnorm2d_{index+1}"] = nn.BatchNorm2d(out_channels)

            (in_channels, out_channels, kernel_size, stride, padding) = (
                self.layers_config[-1]
            )
            layers["out"] = nn.Conv2d(
                in_channels, out_channels, kernel_size, stride, padding, bias=False
            )
            layers["sigmoid"] = nn.Sigmoid()

            return nn.Sequential(layers)
        else:
            raise ValueError("layers_config cannot be None".capitalize())

    def forward(self, x):
        """
        Defines the forward pass of the Discriminator with the given input `x`.

        ## Parameters

        | Parameter | Type      | Description                                   |
        |-----------|-----------|-----------------------------------------------|
        | x         | `Tensor`  | The input tensor with shape [N, C, H, W].     |

        ## Returns

        | Return    | Type      | Description                                   |
        |-----------|-----------|-----------------------------------------------|
        | output    | `Tensor`  | A tensor with shape [N, 1] representing the discriminator's assessment of the input images' authenticity. |

        ## Example

        ```python
        # Assuming `x` is your input tensor with the correct shape.
        output = netD(x)
        ```
        """
        return self.model(x)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Define the Discriminator model".title()
    )

    parser.add_argument(
        "--model",
        action="store_true",
        help="Define the model of discriminator".capitalize(),
    )

    args = parser.parse_args()

    if args.model:
        netD = Discriminator()
        logging.info(netD)
    else:
        raise Exception("Please provide the correct arguments".capitalize())
